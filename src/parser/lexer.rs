use chumsky::prelude::*;

#[derive(Clone, Debug, PartialEq, Eq, Hash)]
pub enum Token {
    If,
    Then,
    Else,
    Let,
    For,
    While,
    Fn,
    Return,
    Break,
    Continue,
    Match,
    In,
    To,
    As,
    LParen,
    RParen,
    LBrace,
    RBrace,
    LBracket,
    RBracket,
    Semicolon,
    Comma,
    SQuote,
    DQuote,
    Assign,
    Eq,
    Neq,
    Lt,
    Gt,
    Lte,
    Gte,
    Plus,
    Minus,
    Mul,
    Div,
    Mod,
    And,
    Or,
    Not,
    BitAnd,
    BitOr,
    BitXor,
    BitNot,
    BitLShift,
    BitRShift,
    Dot,
    Colon,
    Arrow,
    Backslash,
    Underscore,
    Int(u64),
    Ident(String),
}

pub fn lexer() -> impl Parser<char, Vec<Token>, Error = Simple<char>> {
    let tokens = choice::<_, Simple<char>>((
        just('=').then_ignore(just('=')).to(Token::Eq),
        just('!').then_ignore(just('=')).to(Token::Neq),
        just('<').then_ignore(just('=')).to(Token::Lte),
        just('>').then_ignore(just('=')).to(Token::Gte),
        just('&').then_ignore(just('&')).to(Token::And),
        just('|').then_ignore(just('|')).to(Token::Or),
        just('<').then_ignore(just('<')).to(Token::BitLShift),
        just('>').then_ignore(just('>')).to(Token::BitRShift),
        just('-').then_ignore(just('>')).to(Token::Arrow),
        just('.').then_ignore(just('.')).to(Token::To),
    ))
    .or(choice::<_, Simple<char>>([
        just('(').to(Token::LParen),
        just(')').to(Token::RParen),
        just('{').to(Token::LBrace),
        just('}').to(Token::RBrace),
        just('[').to(Token::LBracket),
        just(']').to(Token::RBracket),
        just(';').to(Token::Semicolon),
        just(',').to(Token::Comma),
        just('\'').to(Token::SQuote),
        just('"').to(Token::DQuote),
        just('=').to(Token::Assign),
        just('<').to(Token::Lt),
        just('>').to(Token::Gt),
        just('+').to(Token::Plus),
        just('-').to(Token::Minus),
        just('*').to(Token::Mul),
        just('/').to(Token::Div),
        just('%').to(Token::Mod),
        just('!').to(Token::Not),
        just('&').to(Token::BitAnd),
        just('|').to(Token::BitOr),
        just('^').to(Token::BitXor),
        just('~').to(Token::BitNot),
        just('.').to(Token::Dot),
        just(':').to(Token::Colon),
        just('\\').to(Token::Backslash),
        just('_').to(Token::Underscore),
    ]))
    .or(choice::<_, Simple<char>>((
        text::keyword("if").to(Token::If),
        text::keyword("then").to(Token::Then),
        text::keyword("else").to(Token::Else),
        text::keyword("for").to(Token::For),
        text::keyword("while").to(Token::While),
        text::keyword("fn").to(Token::Fn),
        text::keyword("let").to(Token::Let),
        text::keyword("return").to(Token::Return),
        text::keyword("match").to(Token::Match),
        text::keyword("in").to(Token::In),
        text::keyword("break").to(Token::Break),
        text::keyword("continue").to(Token::Continue),
        text::keyword("as").to(Token::As),
        text::int(10).from_str::<u64>().unwrapped().map(Token::Int),
        text::ident().map(Token::Ident),
    )))
    .padded()
    .repeated();
    tokens.then_ignore(end())
}
